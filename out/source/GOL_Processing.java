/* autogenerated by Processing revision 1286 on 2022-10-12 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class GOL_Processing extends PApplet {

int N = 10;
Grid GRID = new Grid(N);
Grid NEXTGEN;
boolean EDITING = true;
boolean RUNNING = !EDITING;
boolean themeIsLight = true;

 public void setup() {
  /* size commented out by preprocessor */;
  background(0);
  
  GRID.setTheme(themeIsLight);
  GRID.drawMe();
}

 public void draw() {
  if(RUNNING) {
   GRID = GRID.getNextGen();
   GRID.setTheme(themeIsLight);
   GRID.drawMe();
   delay(100);
  }
}

 public void mousePressed() {
  // Fill or unfill cell by mousepress
  if(EDITING) {
    GRID.updateEditing();
  }
}

 public void keyPressed() {
  // Clear grid in editing mode
  if(EDITING && key == 'c' || key == 'C') {
   GRID = new Grid(N);
   GRID.setTheme(themeIsLight);
   GRID.drawMe();
  }
  
  // Enter editing mode and leave running mode or other way around
  if(key == 'e' || key == 'E' || key == ' ') {
     RUNNING = !RUNNING;
     EDITING = !EDITING;
     println("Editing: " + EDITING);
  }
  
  // Change theme, light->dark, dark->light
  if(key == 't' || key == 'T') {
    themeIsLight = !themeIsLight;
    GRID.setTheme(themeIsLight);
    GRID.drawMe();
  }
  
  // one step forward
  if(EDITING && key == 's' || key == 'S') {
    GRID = GRID.getNextGen();
    GRID.setTheme(themeIsLight);
    GRID.drawMe();
  }
  
  // edit N with arrow keys betwenn 10 and 100, only when EDITING, will delete cells
  if(EDITING && key == CODED) {
   if(N <= 100 && keyCode == 38) {
    clear();
     N+=10;
     GRID = new Grid(N);
     GRID.setTheme(themeIsLight);
     GRID.drawMe();
     println("New N = " + N);
   }
   
   if(N > 10 && keyCode == 40) {
     clear();
     N-=10;
     GRID = new Grid(N);
     GRID.setTheme(themeIsLight);
     GRID.drawMe();
     println("New N = " + N);
   }
  }

  // Exit program
  if(key == 'x' || key == 'X') {
    exit(); 
  } 
}

// up = true --> N+=, up = false --> N-=
 public void updateN(boolean up) {

}
class Cell {
  
 int xPos;
 int yPos;
 boolean state;
 
 Cell(int tempXPos, int tempYPos, boolean tempState) {
   xPos = tempXPos;
   yPos = tempYPos;
   state = tempState;
 }

  public void setAlive() {
  state = true;
 }

  public void setDead() {
  state = false;
 }
 
  public void setState(boolean newState) {
  state = newState;
 }
 
 
}
class Grid {
  
 int n;
 Cell[][] cells;
 boolean lightTheme = true;
 int colorAlive = 0;
 int colorDead = 255;
 int strokeColor = 150;
  
  Grid(int tempN){
    n = tempN;
    cells = new Cell[n][n];
    
    for(int x = 0; x < n; x++) {
      for(int y = 0; y < n; y++) {
        cells[x][y] = new Cell(x, y, false);
      }
     }
    
  }

   public void setTheme(boolean isLight) {
    if(isLight) {
      lightTheme = !lightTheme;
     
     colorDead = 255;
     colorAlive = 0;
     strokeColor = 100; 
    }
    if(!isLight) {
     lightTheme = !lightTheme;
     
     colorDead = 0;
     colorAlive = color(255, 153, 204);
     strokeColor = 100; 
    }

  }
  
   public void drawMe() {
    float squareWidth = width/n;
  
    for(int x = 0; x < n; x++) {
      for(int y = 0; y < n; y++) {          
        stroke(strokeColor);
     
        if(!cells[x][y].state) {
          fill(colorDead);  
        }
        else{
          fill(colorAlive); 
        } 
        if(cells[x][y].state) {
        }
        else {
        }
        rect(x*squareWidth, y*squareWidth, squareWidth, squareWidth);     
      }
    }
  }
  
   public void updateEditing() {
    int tempX = (int) mouseX / (width/n);
    int tempY = (int) mouseY / (width/n);
    
    if(tempX != 0 && tempX != n-1 && tempY != 0 && tempY != n-1) {
      if(cells[tempX][tempY].state) {
      cells[tempX][tempY].setDead();  
    }
      else {
        cells[tempX][tempY].setAlive(); 
      }
      drawMe();
    }
  }
 
   public int countAliveNeighbours(Cell cell) {
    int count = 0;
    // Zeile darueber
        if(cell.yPos >= 1) {
            for(int i = cell.xPos-1 ; i <= cell.xPos+1 ; i++) {
                if(cells[i][cell.yPos-1].state && cell.xPos >= 1) {
                    count++;
                }
            }
        }
        
        // Zeile darunter
        for(int i = cell.xPos-1 ; i <= cell.xPos+1 ; i++) {
          
            if(cells[i][cell.yPos+1].state && cell.xPos >= 1) {
                count++;
            }
            
        }
        // Links
        if(cells[cell.xPos-1][cell.yPos].state && cell.xPos >= 1) {
            count++;;
        }
        // Rechts
        if(cells[cell.xPos+1][cell.yPos].state) {
            count++;
        }
    return count;
  }
  
   public boolean willSurvive(int x, int y) {
    
    Cell cell = cells[x][y];
    
    int neighbours = countAliveNeighbours(cell);
   
    if(cell.state){
      if(neighbours == 2 || neighbours == 3) {
        return true; 
      }
      if(neighbours > 3 || neighbours < 2) {
        return false; 
      }
    }
    if(!cell.state && neighbours == 3) {
      return true; 
    }
    return false;
  }
  
  public Grid getNextGen() {
  Grid nextGrid = new Grid(n);
  
  for(int x = 1 ; x < n-1 ; x++) {
    for(int y = 1 ; y < n-1 ; y++) {
     nextGrid.cells[x][y].setState(this.willSurvive(x, y));
    }
  }
   return nextGrid;
 }
}

  


  public void settings() { size(800, 800); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "GOL_Processing" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
